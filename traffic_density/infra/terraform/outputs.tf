# Outputs for Traffic Detection Infrastructure

output "sns_topic_arn" {
  description = "ARN of the SNS topic for traffic alerts"
  value       = aws_sns_topic.traffic_alerts.arn
}

output "sns_topic_name" {
  description = "Name of the SNS topic"
  value       = aws_sns_topic.traffic_alerts.name
}

output "iam_user_name" {
  description = "IAM user name for the application"
  value       = aws_iam_user.traffic_app_user.name
}

output "aws_access_key_id" {
  description = "AWS Access Key ID for the application user"
  value       = aws_iam_access_key.traffic_app_key.id
}

output "aws_secret_access_key" {
  description = "AWS Secret Access Key for the application user"
  value       = aws_iam_access_key.traffic_app_key.secret
  sensitive   = true
}

output "sqs_queue_url" {
  description = "URL of the SQS queue (if enabled)"
  value       = var.enable_sqs_queue ? aws_sqs_queue.traffic_events[0].url : null
}

output "sqs_queue_arn" {
  description = "ARN of the SQS queue (if enabled)"
  value       = var.enable_sqs_queue ? aws_sqs_queue.traffic_events[0].arn : null
}

output "s3_bucket_name" {
  description = "Name of the S3 bucket for images (if enabled)"
  value       = var.enable_s3_storage ? aws_s3_bucket.traffic_images[0].id : null
}

output "cloudwatch_log_group" {
  description = "CloudWatch log group name (if enabled)"
  value       = var.enable_cloudwatch ? aws_cloudwatch_log_group.traffic_logs[0].name : null
}

output "region" {
  description = "AWS region where resources are deployed"
  value       = var.aws_region
}

# Output for .env file generation
output "env_file_content" {
  description = "Content for .env file"
  value = <<-EOT
    # AWS Configuration - Generated by Terraform
    # Date: ${timestamp()}
    
    # AWS Credentials
    AWS_ACCESS_KEY_ID=${aws_iam_access_key.traffic_app_key.id}
    AWS_SECRET_ACCESS_KEY=${aws_iam_access_key.traffic_app_key.secret}
    AWS_DEFAULT_REGION=${var.aws_region}
    
    # SNS Topic ARN
    AWS_SNS_TOPIC_ARN=${aws_sns_topic.traffic_alerts.arn}
    
    # Enable AWS SNS
    ENABLE_AWS_SNS=true
    
    # Optional: S3 Bucket (if enabled)
    ${var.enable_s3_storage ? "AWS_S3_BUCKET=${aws_s3_bucket.traffic_images[0].id}" : "# AWS_S3_BUCKET=<not-enabled>"}
    
    # Optional: SQS Queue (if enabled)
    ${var.enable_sqs_queue ? "AWS_SQS_QUEUE_URL=${aws_sqs_queue.traffic_events[0].url}" : "# AWS_SQS_QUEUE_URL=<not-enabled>"}
  EOT
  sensitive = true
}

output "setup_instructions" {
  description = "Instructions for setting up the application"
  value = <<-EOT
    
    ========================================
    üéâ Infrastructure Created Successfully!
    ========================================
    
    üìã Next Steps:
    
    1. Save credentials to .env file:
       terraform output -raw env_file_content > ../../.env
    
    2. Confirm email subscriptions:
       Check your inbox for SNS confirmation emails
    
    3. Test SNS publishing:
       aws sns publish \\
         --topic-arn ${aws_sns_topic.traffic_alerts.arn} \\
         --message '{"test": "message"}' \\
         --message-group-id "test-group" \\
         --message-deduplication-id "test-$(date +%s)"
    
    4. Rebuild application with AWS support:
       cd ../../build
       cmake -DENABLE_AWS_SNS=ON ..
       make
    
    5. Run the application:
       ./main_exec demo
    
    üìä Resources Created:
    - SNS Topic: ${aws_sns_topic.traffic_alerts.name}
    - IAM User: ${aws_iam_user.traffic_app_user.name}
    - Email Subscriptions: ${length(var.notification_emails)}
    ${var.enable_sqs_queue ? "- SQS Queue: ${aws_sqs_queue.traffic_events[0].name}" : ""}
    ${var.enable_s3_storage ? "- S3 Bucket: ${aws_s3_bucket.traffic_images[0].id}" : ""}
    
    ‚ö†Ô∏è  Security Note:
    Your credentials are in Terraform state!
    - Run: terraform output -raw aws_secret_access_key
    - Store securely and never commit to Git
    
    ========================================
  EOT
}

# Lambda Outputs
output "ecr_repository_url" {
  description = "ECR repository URL for Lambda container images"
  value       = var.enable_lambda ? aws_ecr_repository.traffic_detector[0].repository_url : null
}

output "lambda_function_name" {
  description = "Name of the Lambda function"
  value       = var.enable_lambda ? aws_lambda_function.traffic_detector[0].function_name : null
}

output "lambda_function_arn" {
  description = "ARN of the Lambda function"
  value       = var.enable_lambda ? aws_lambda_function.traffic_detector[0].arn : null
}

output "lambda_role_arn" {
  description = "ARN of the Lambda execution role"
  value       = var.enable_lambda ? aws_iam_role.lambda_execution[0].arn : null
}

output "lambda_log_group" {
  description = "CloudWatch log group for Lambda function"
  value       = var.enable_lambda ? aws_cloudwatch_log_group.lambda_logs[0].name : null
}

output "eventbridge_rule_name" {
  description = "EventBridge rule name for Lambda scheduling"
  value       = var.enable_lambda ? aws_cloudwatch_event_rule.lambda_schedule[0].name : null
}

output "docker_build_instructions" {
  description = "Instructions for building and pushing Docker image to ECR"
  value = var.enable_lambda ? "Run './deploy-lambda.sh' to deploy the Lambda function, or see LAMBDA_DEPLOYMENT.md for manual steps" : null
}




